                                                               DSA
Tower of Hanoi:

import java.util.*;
class Main {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        towerOfhanoi(n,'A','C','B');
    }
    static void towerOfhanoi(int n, char from_rod, char to_rod, char aux_rod){
        towerOfhanoi(n-1,from_rod,aux_rod,to_rod);
        System.out.println("Disk "+n+"move from "+from_rod+"to "+to_rod);
        towerOfhanoi(n-1,aux_rod,to_rod,from_rod);
    }
}

Spiral matrix:

class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        ArrayList<Integer> result=new ArrayList<>();
        if(matrix.length==0 || matrix[0].length==0){
            return result;
        }
        int m=matrix.length,n=matrix[0].length;
        int left=0, right=n-1, top=0, bottom=m-1;
        while(left<=right && top<=bottom){
            for(int i=left; i<=right; i++){//top traverse
                result.add(matrix[top][i]);
            }top++;
            for(int i=top; i<=bottom; i++){//right traverse
                result.add(matrix[i][right]);
            }right--;
            if(top<=bottom){
            for(int i=right; i>=left; i--){
                result.add(matrix[bottom][i]);
            }bottom--;
            }
            if(left<=right){
            for(int i=bottom; i>=top; i--){
                result.add(matrix[i][left]);
            }left++;
            }
        }
      return result;  
    }
}


Anagrams:

import java.util.*;
class Main {
    public static void main(String[] args) {
        String s1="Hello".toLowerCase();
        String s2="heoll";
        if(s1.length()!=s2.length()){
             System.out.println("false");
        }
        else{
            char[] arr1=s1.toCharArray();
            char[] arr2=s2.toCharArray();
            Arrays.sort(arr1);
            Arrays.sort(arr2);
            System.out.println(Arrays.equals(arr1, arr2));
        }
    }
}

Occurences in a string:

import java.util.*;
class Main {
    public static void main(String[] args) {
        String s1="Hello";
        LinkedHashMap<Character, Integer> hash=new LinkedHashMap<>();
        for(char c:s1.toCharArray()){
            hash.put(c, hash.getOrDefault(c, 0)+1);
        }
        for(Map.Entry e:hash.entrySet()){
            System.out.println(e.getKey()+" "+e.getValue());
        }        
    }
} using only hashmap it gives output in sorted order 
if we use Linkedhashmap it gives based on input   

Occurences in a string without hash function:

import java.util.*;
class Main {
    public static void main(String[] args) {
        String s1="Hello";
        StringBuilder t=new StringBuilder();
        int c=1;
        for(int i=1; i<s1.length(); i++){
            if(s1.charAt(i)==s1.charAt(i-1)){
                c++;
            }
            else{
                t.append(s1.charAt(i-1)).append(" ").append(c).append("\n");
                
            }
        }
        System.out.println(t.toString());
    }
} 

Majority of an element:

import java.util.*;
class Main {
    public static void main(String[] args) {
        int[] arr={1,1,3,1,2,5,3,2};
        LinkedHashMap<Integer, Integer> hash=new LinkedHashMap<>();
        for(int c:arr){
            hash.put(c, hash.getOrDefault(c, 0)+1);
        }
        int maxfreq=0;
        int maxele=-1;
        for(Map.Entry<Integer, Integer> e:hash.entrySet()){
            if(e.getValue()>maxfreq){
                maxfreq=e.getValue();
                maxele=e.getKey();
            }
        }
        System.out.println(maxele);
        
    }
}

pgm to change the casing of a letter in a string

class StringCaseChanger {
    public static String toggleCase(String inputString) {
        if (inputString == null || inputString.isEmpty()) {
            return inputString;
        }

        StringBuilder result = new StringBuilder(inputString.length());

        for (char character : inputString.toCharArray()) {
            if (Character.isUpperCase(character)) {
                result.append(Character.toLowerCase(character));
            } else if (Character.isLowerCase(character)) {
                result.append(Character.toUpperCase(character));
            } else {
                result.append(character);
            }
        }

        return result.toString();
    }
}

pgm to print ASCII value of a string
public class StringAsciiPrinter {

    public static void printAsciiValues(String inputString) {
        if (inputString == null || inputString.isEmpty()) {
            System.out.println("Input string is null or empty. No ASCII values to print.");
            return;
        }

        System.out.println("ASCII values for string: \"" + inputString + "\"");
        for (int i = 0; i < inputString.length(); i++) {
            char character = inputString.charAt(i);
            int asciiValue = (int) character;

            System.out.println("Character: '" + character + "' -> ASCII Value: " + asciiValue);
        }
    }
}

print given string in alphabetical order:
import java.util.*;
class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String s=sc.nextLine();
        String res=" ";
        String[] arr=s.split(" ");
        for(int i=0; i<arr.length; i++){
            char[] ch=arr[i].toCharArray();
            Arrays.sort(ch);
            res=res+new String(ch)+" ";
        }
        System.out.println(res.trim());
    }
}    
 LinkedList:
java
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class LinkedListDemo {
    public static void main(String[] args) {
        Node head = new Node(10);
        head.next = new Node(20);
        head.next.next = new Node(30);

        // Print list
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
    }
}

program to insert a node at the beg:
import java.util.*;
class Main {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        node head=null;
        for(int i=0; i<n; i++){
            int data=sc.nextInt();
            head=insertAtbeg(head, data);
        }
        printlist(head);
    }
static class node{
    int data;
    node next;
    node(int data){
        this.data=data;
        next=null;
    }
}
  public static node insertAtbeg(node head,int data){
        node newnode=new node(data);
        if(head==null){
            return newnode;
        }
        newnode.next=head;
        return newnode;
    }
    public static void printlist(node head){
        node temp=head;
        if(temp==null){
            System.out.print(temp.data+" ");
        }
        while(temp!=null){
            System.out.print(temp.data+" ");
            temp=temp.next;
        }
    }
}

josephus problem:

import java.util.*;
class Main {
    public static void main(String[] args) {
        int n=6;
        int k=2;
        System.out.print(joseph(n, k));
    }
    static int joseph(int n, int k){
        if(n==1) return 1;
        else return (joseph(n-1, k)+k-1)%n+1;
    }
}

Circular Linkedlist:
josephus problem using circular linkedlist:

import java.util.*;
class singlyLinkedList{
    class Node{
    int data;
    Node next;
    Node(int data){
        this.data=data;
        this.next=null;
    }
}
    Node head=null;
    Node tail=null;
    public void createcll(int n){
        for(int i=1; i<=n; i++){
            Node newnode=new Node(i);
            if(head==null){
                head=newnode;
                tail=newnode;
                newnode.next=head;
            }
            else{
                tail.next=newnode;
                tail=newnode;
                tail.next=head;
            }
        }
    }
    public int display(int k){
        if(head==null){
            return 0;
        }
        Node curr=head;
        Node prev=tail;
        while(curr.next!=curr){
            for(int i=1; i<k; i++){
                prev=curr;
                curr=curr.next;
            }
            prev.next=curr.next;
            if(curr==head){
                head=curr.next;
            }
            curr=curr.next;
        }
        return curr.data;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        singlyLinkedList s=new singlyLinkedList();
        s.createcll(n);
        System.out.println(s.display(k));
    }
}

// Online Java Compiler

import java.util.*;
class Main {
    static int top=-1;
    static int[] array=new int[100];
    public static void main(String[] args) {
        int[] arr={1, 2, 3, 4, 5};
        for(int val:arr){
            push(val);
        }
        push(4);
        push(1);
        pop();
        display();
        
    }
    public static void push(int a){
        if(top==array.length-1){
            System.out.println("Stack is overflow");
     return;
        }
        top=top+1;
        array[top]=a;
    }
        public static void pop(){
            if(top==-1){
               System.out.println("Stack is empty"); 
            }
            else{
                System.out.println("pop element is: "+ array[top]); 
                top=top-1;
            }
        }
        public static void display(){
            if(top==-1){
               System.out.println("Stack is empty"); 
            }
            else{
                for(int i=top;i>=0;i--){
                    System.out.print(array[i]+" "); 
                }
            }
        }
}  

 Stack implementaion using linkedlist:

import java.util.*;
class Main {
    public static void main(String[] args) {
       Stackll st=new Stackll();
       st.push(1);
       st.push(3);
       st.push(5);
       st.push(2);
       st.push(4);
       st.display();
       st.pop();
       st.push(9);
       st.display();
       st.pop();
       st.pop();
      st.display();
    }
}
class Stackll{    
    static class Node{
    int data;
    Node next;
    Node(int data){
        this.data=data;
        this.next=null;
    }
}
    private Node top=null;
    public void push(int data){
        Node newnode=new Node(data);
        newnode.next=top;
        top=newnode;
    }
    public void pop(){
        if(top==null){
            System.out.println("Stack is empty");
            return;
        }
        System.out.println(top.data);
        top=top.next;
    }
    public void display(){
       if(top==null){
            System.out.println("Stack is empty");
            return;
        }
        Node temp=top;
        while(temp!=null){
            System.out.print(temp.data+" ");
            temp=temp.next;
        }
        System.out.println();
    }
}
 
check whether given num is palindrome or not using stack :

import java.util.*;
class Main {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
       Stack<Character> st=new Stack<>();
       String s=String.valueOf(n);
       for(int i=0; i<s.length()/2; i++){
           st.push(s.charAt(i));
       }
       int mid=s.length()/2+1;
       if(s.length()%2!=0){
           mid=s.length()/2;
       }
       for(int i=mid; i<s.length(); i++){
           if(st.peek()==s.charAt(i)){
               st.pop();
           }
       }
       System.out.println(st.empty());
    }
}

Queue:

I


Linear search implementation using recursion:

class Main {
    public static void main(String[] args) {
        int[] arr={10, 39, 20, 34, 54};
        System.out.println(linearsearch(arr, 0, 34));
    }
    public static int linearsearch(int[] arr, int i, int target){
        if(arr.length==0){
            return -1;
        }
        if(i==arr.length){
            return -1;
        }
        if(arr[i]==target){
            return i;
        }
        
            return linearsearch(arr, i+1, target);
        
    }
}

Binary search:
Binary search implementation:

import java.util.*;
class Main {
    public static void main(String[] args) {
        int[] arr={10, 39, 20, 34, 53};
        System.out.println(binarysearch(arr, 53));
    }
    public static boolean binarysearch(int[] arr, int target){
        int left=0; 
        int right=arr.length-1;
        Arrays.sort(arr);
        while(left<=right){
            int mid=(left+right)/2;
        if(arr[mid]==target) return true;
        if(arr[mid]>target){
            right=mid-1;
        }else{
            left=mid+1;
        }
        } return false;
        
    }
}

problem: arr={3, 1, 2, 2, 2, 1, 2, 3, 3} , k=4, we have to check n/k if occurence of an element >n/k print that number Note: array should be sorted 

import java.util.*;
class Main {
    public static void main(String[] args) {
        int[] arr={3, 1, 2, 2, 2, 1, 2, 3, 3};
        System.out.println(binarysearch(arr,4));
    }
    public static ArrayList<Integer> binarysearch(int[] arr, int k){
        Arrays.sort(arr);
        ArrayList<Integer> a =new ArrayList<>();
        int i=0;
        while(i<arr.length){
            int count=1, j=i+1;
            while(j<arr.length && arr[i]==arr[j]){
                    count++;
                    j++;
            }
            if(count>(arr.length-1)/k){
                a.add(arr[i]);
            }
            i=j;
        }
        return a;
        
    }
}
Sorting techniques:
1.Bubble sort:
import java.util.*;
class Main {
    public static void main(String[] args) {
        int[] arr={3, 1, 2, 2, 2, 1, 2, 3, 3};
        bubblesort(arr);
    }
    public static void bubblesort(int[] arr){
        for(int i=0; i<arr.length; i++){
            for(int j=0; j<arr.length-1-i; j++){
                if(arr[j]>arr[j+1]){
                    int temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }
        }
        for(int a:arr){
            System.out.print(a+" ");
        }
        
    }
}

Selection Sort :
import java.util.*;
class Main {
    public static void main(String[] args) {
        int[] arr={3, 2, 1, 4, 3, 4};
        selectionsort(arr);
    }
    public static void selectionsort(int[] arr){
        
        for(int i=0; i<arr.length; i++){
           int minidx=i; 
        for(int j=i+1; j<arr.length; j++){
            if(arr[minidx]>arr[j]){
                minidx=j;
            }    
        }
        if(arr[i]>arr[minidx]){
            int temp=arr[i];
            arr[i]=arr[minidx];
            arr[minidx]=temp;
        }
        }
        for(int a:arr){
            System.out.print(a+" ");
        }
        
    }
}
 
Insertion sort:

import java.util.*;
class Main {
    public static void main(String[] args) {
        int[] arr={3, 2, 1, 4, 3, 4};
        selectionsort(arr);
    }
    public static void selectionsort(int[] arr){
        
        for(int i=1; i<arr.length; i++){
            int key=arr[i];
            int j=i-1;
        while(j>=0 && arr[j]>key){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=key;
        }
        for(int a:arr){
            System.out.print(a+" ");
        }
        
    }
}
Quick Sort:
Algorithm:
quicksort(arr, low ,high)
if(low<high)
pivot_idx=Partition(array, low, high)
quicksort(arr, low, pivot_idx-1)
quicksort(arr, pivot+1, high)
Partition(arr, low, high)
pivot=arr[high]
i=low-1
for i from low to high-1
if arr[j]<=pivot
i=i+1
swap(arr[i], arr[j])

COde:
public class Main
{
	public static void main(String[] args) {
		int[] arr={2, 3, 7, 9, 5};
		quicksort(arr, 0, arr.length-1);
		print(arr);
		
	}
	public static void quicksort(int[] arr, int low, int high){
	    if(low<high){
	        int p=partition(arr, low, high);
	        quicksort(arr, low, p-1);
	        quicksort(arr, p+1, high);
	    }
	}
	public static int partition(int[] arr, int low, int high){
	    int pivot=arr[high];
	    int i=low-1;
	    for(int j=low; j<high; j++){
	        if(arr[j]<pivot){
	            i++;
	            int temp=arr[j];
	            arr[j]=arr[i];
	            arr[i]=temp;
	        }
	    }
	    int temp=arr[i+1];
	    arr[i+1]=arr[high];
	    arr[high]=temp;
	    return i+1;
	    
	}
	public static void print(int[] arr){
	    for(int a: arr){
	        System.out.print(a+" ");
	    }
    }
}

Merge sort:
Structure of binary tree:

class TreeNode {
    int data;
    TreeNode left;  // Left child
    TreeNode right; // Right child

    TreeNode(int val) {
        data = val;
        left = null;
        right = null;
    }
}

logic:
if (root == null) return;
        inorder(root.left);         // Step 1: Traverse left subtree
         System.out.print(root.data + " ");   // Step 2: Visit current node
        inorder(root.right);   // Step 3: Traverse right subtree

2. Preorder Traversal Rule:
(Node → Left → Right)

Visit the current node
Traverse the left subtree
Traverse the right subtree

Logic:
void preorder(TreeNode root) {
    if (root == null) return;

    System.out.print(root.data + " "); // 1. Visit node
    preorder(root.left);              // 2. Traverse left
    preorder(root.right);             // 3. Traverse right
}

3. Postorder Traversal rule:
(Left → Right → Node)
Traverse the left subtree
Traverse the right subtree
Visit the current node

Logic:

void postorder(TreeNode root) {
    if (root == null) return;

    postorder(root.left);             // 1. Traverse left
    postorder(root.right);            // 2. Traverse right
    System.out.print(root.data + " "); // 3. Visit node
}

Program for preorder:

class Node{
    int data;
    Node left; 
    Node right; 
    Node root;
    Node(int val){
        data=val;
        left=null;
        right=null; 
    }
}
class Main {
    public static void main(String[] args) {
        Node node=new Node(11);
        node.left=new Node(12);
        node.left.left=new Node(16);
        node.left.right=new Node(17);
        node.right=new Node(13);
        node.right.left=new Node(14);
        node.right.right=new Node(15);
        preorder(node);
    }
    public static void preorder(Node root){
        if(root==null) return ;
        System.out.print(root.data+" ");
        preorder(root.left);
        preorder(root.right);
    }
}

check if two trees are have data & structure:

class Node {
    int data;
    Node left, right;
    Node(int val) {
        data = val;
        left = right = null;
    }
}

public class TreeEquality {

    public static boolean isSameTree(Node root1, Node root2) {
        // If both are null, they're equal
        if (root1 == null && root2 == null) return true;

        // If one is null and other isn't, not equal
        if (root1 == null || root2 == null) return false;

        // Check current node values and their children
        return (root1.data == root2.data)
            && isSameTree(root1.left, root2.left)
            && isSameTree(root1.right, root2.right);
    }

    public static void main(String[] args) {
        // Tree 1
        Node root1 = new Node(1);
        root1.left = new Node(2);
        root1.right = new Node(3);

        // Tree 2
        Node root2 = new Node(1);
        root2.left = new Node(2);
        root2.right = new Node(3);

        if (isSameTree(root1, root2))
            System.out.println("Both trees are equal.");
        else
            System.out.println("Trees are NOT equal.");
    }
}

Preoder traversal taking input from user:

import java.util.*;

class Node {
    int data;
    Node left, right;

    Node(int val) {
        data = val;
    }
}

public class TreeInput {

    public static Node buildTree() {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter root: ");
        int val = sc.nextInt();
        if (val == -1) return null;

        Node root = new Node(val);
        Queue<Node> q = new LinkedList<>();
        q.offer(root);

        while (!q.isEmpty()) {
            Node curr = q.poll();

            System.out.print("Enter left of " + curr.data + ": ");
            int leftVal = sc.nextInt();
            if (leftVal != -1) {
                curr.left = new Node(leftVal);
                q.offer(curr.left);
            }

            System.out.print("Enter right of " + curr.data + ": ");
            int rightVal = sc.nextInt();
            if (rightVal != -1) {
                curr.right = new Node(rightVal);
                q.offer(curr.right);
            }
        }

        return root;
    }

    public static void preorder(Node root) {
        if (root == null) return;
        System.out.print(root.data + " ");
        preorder(root.left);
        preorder(root.right);
    }

    public static void main(String[] args) {
        Node root = buildTree();
        System.out.println("Preorder traversal:");
        preorder(root);
    }
}

1. Height of a Tree:
 Recursive Formula:

height = 1 + max(height of left subtree, height of right subtree)
Program:
 class Node {
    int data;
    Node left, right;
    Node(int val) {
        data = val;
        left = right = null;
    }
}

public class TreeHeight {

    public static int findHeight(Node root) {
        if (root == null) return -1;  // height of empty tree is -1 (or 0 if you prefer counting nodes)
        int left = findHeight(root.left);
        int right = findHeight(root.right);
        return 1 + Math.max(left, right);
    }

    public static void main(String[] args) {
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);

        System.out.println("Height of tree: " + findHeight(root));
    }
}

2. Degree of a Tree or Node
 Degree of a Node:
Number of children that node has

E.g. Node with 2 children → degree = 2

Degree of the Tree:
The maximum degree among all nodes

Program:

public class TreeDegree {

    public static int maxDegree(Node root) {
        if (root == null) return 0;

        int degree = 0;
        if (root.left != null) degree++;
        if (root.right != null) degree++;

        int leftDegree = maxDegree(root.left);
        int rightDegree = maxDegree(root.right);

        return Math.max(degree, Math.max(leftDegree, rightDegree));
    }

    public static void main(String[] args) {
        Node root = new Node(1);
        root.left = new Node(2);         // degree 2
        root.right = new Node(3);
        root.left.left = new Node(4);    // degree 0
        root.left.right = new Node(5);   // degree 0

        System.out.println("Degree of tree: " + maxDegree(root));
    }
}

To count no of leaf nodes:

class Node{
    int val;
    Node left, right;
    Node(int val){
        this.val=val;
        left=null;
        right=null;
    }
}
class Main {
    public static void main(String[] args) {
        Node node=new Node(11);
        node.left=new Node(12);
        node.right=new Node(19);
        node.right.left=new Node(13);
        System.out.println(leafnode(node));
    }
    public static int leafnode(Node node){
        if(node==null) return 0;
        if(node.left==null && node.right==null) return 1;
        return leafnode(node.left)+leafnode(node.right);
    }
}

Binarysearch tree:
Binary search tree implementation:
class Node{
    int data; 
    Node left, right;
    Node(int data){
        this.data=data;
        left=right=null;
    }
}
public class Main {
    public static Node insert(Node root, int key){
        Node newnode=new Node(key);
        if(root==null) root=newnode;
        else{
            Node temp=root;
            if(temp.data>key){
                root.left=insert(root.left,key);
            }else{
               root.right=insert(root.right,key); 
            }
            
        }
        return root;
    }
    public static void inorder(Node root){
        if(root==null) return;
        inorder(root.left);
        System.out.print(root.data+" ");
        inorder(root.right);
    }
    public static void main(String[] args) {
        Node root =null;
        root=insert(root, 6);
        root=insert(root, 3);
        root=insert(root, 8);
        root=insert(root, 2);
        root=insert(root, 4);
        root=insert(root, 9);
        inorder(root);
    }
}

Delete a key from a tree:

class Node{
    int data; 
    Node left, right;
    Node(int data){
        this.data=data;
        left=right=null;
    }
}
public class Main {
    public static Node insert(Node root, int key){
        Node newnode=new Node(key);
        if(root==null) root=newnode;
        else{
            Node temp=root;
            if(temp.data>key){
                root.left=insert(root.left,key);
            }else{
               root.right=insert(root.right,key); 
            }
            
        }
        return root;
    }
    public static Node delete(Node root, int key){
        if(root==null) return null;
        if(key< root.data) root.left=delete(root.left, key);
        else if(key> root.data) root.right=delete(root.right, key);
        else{
            if(root.left==null) return root.right;
            else if(root.right==null) return root.left;
            Node successor =findmin(root.right);
            root.data=successor.data;
            root.right=delete(root.right, successor.data);
        }
        return root;
    }
    public static Node findmin(Node root){
        while(root!=null){
            root=root.left;
        }
        return root;
    }
    public static void inorder(Node root){
        if(root==null) return;
        inorder(root.left);
        System.out.print(root.data+" ");
        inorder(root.right);
    }
    public static void main(String[] args) {
        Node root =null;
        root=insert(root, 6);
        root=insert(root, 3);
        root=insert(root, 8);
        root=insert(root, 2);
        root=insert(root, 4);
        root=insert(root, 9);
        inorder(root);
        delete(root, 8);
        System.out.println();
        inorder(root);
    }
}

** Program to return the floor of a given number in the binary search tree?

class Node{
    int data; 
    Node left, right;
    Node(int data){
        this.data=data;
        left=right=null;
    }
}
public class Main {
    public static Node insert(Node root, int key){
        Node newnode=new Node(key);
        if(root==null) root=newnode;
        else{
            Node temp=root;
            if(temp.data>key){
                root.left=insert(root.left,key);
            }else{
               root.right=insert(root.right,key); 
            }
            
        }
        return root;
    }
    public static int floor(Node root, int key){
        if(root==null) return -1;
        if(root.data==key) return root.data;
        if(key<root.data){
             return floor(root.left, key);
        }int f=floor(root.right, key);
        return ((f<=key && f!=-1)?f:root.data);
    }
    public static void inorder(Node root){
        if(root==null) return;
        inorder(root.left);
        System.out.print(root.data+" ");
        inorder(root.right);
    }
    public static void main(String[] args) {
        Node root =null;
        root=insert(root, 6);
        root=insert(root, 3);
        root=insert(root, 8);
        root=insert(root, 2);
        root=insert(root, 4);
        root=insert(root, 9);
        inorder(root);
        System.out.println();
        System.out.println(floor(root, 10));
    }
}

** program to find ceil of a key in bst:

class Node{
    int data; 
    Node left, right;
    Node(int data){
        this.data=data;
        left=right=null;
    }
}
public class Main {
    public static Node insert(Node root, int key){
        Node newnode=new Node(key);
        if(root==null) root=newnode;
        else{
            Node temp=root;
            if(temp.data>key){
                root.left=insert(root.left,key);
            }else{
               root.right=insert(root.right,key); 
            }
            
        }
        return root;
    }
    public static int floor(Node root, int key){
        if(root==null) return -1;
        if(root.data==key) return root.data;
        if(key>root.data){
             return floor(root.right, key);
        }int f=floor(root.left, key);
        return ((f>=key && f!=-1)?f:root.data);
    }
    public static void inorder(Node root){
        if(root==null) return;
        inorder(root.left);
        System.out.print(root.data+" ");
        inorder(root.right);
    }
    public static void main(String[] args) {
        Node root =null;
        root=insert(root, 6);
        root=insert(root, 3);
        root=insert(root, 8);
        root=insert(root, 2);
        root=insert(root, 4);
        root=insert(root, 9);
        inorder(root);
        System.out.println();
        System.out.println(floor(root, 5));
    }
}

 Greedy Strategy:
1.Activity Selection:
Program for activity selection:
class Solution {
    public int activitySelection(int[] start, int[] finish) {
        int n=start.length;
        int[][] arr1=new int[n][2];
        for(int i=0; i<n; i++){
            arr1[i][0]=start[i];
            arr1[i][1]=finish[i];
        }
        Arrays.sort(arr1, (a, b) -> a[1]-b[1]);
        int count=1, e=arr1[0][1];
        for(int i=1; i<arr1.length; i++){
            if(arr1[i][0]>e){
                count++;
                e=arr1[i][1];
            }
        }
        return count;
        
    }
}
HeapSort:
import java.util.*;
class Main {
    public static void main(String[] args) {
        int arr[]={1, 2, 3, 4, 6, 3, 7};
        int k=3;
        Arrays.sort(arr);
        int sum=0, j=0;
        for(int i=arr.length-1; i>=0; i--){
            if(j<arr.length){
            sum+=arr[i]*(1+j/k);
            j++;
            }
        }
        System.out.println(sum);
    }
}

Fractional Knapsack:
import java.util.*;
class Main {
    public static void main(String[] args) {
        int arr[][]={{25, 18}, {24, 15}, {15, 10}};
        int k=20;
        int[] res=new int[arr.length];
        Arrays.sort(arr, (a, b)->{
        double r1=(double)a[0]/a[1];
        double r2=(double)b[0]/b[1];
        return Double.compare(r2, r1);
        });
        double cost=0;
        for(int i=0; i<arr.length; i++){
          if(k>=arr[i][1]){
              cost+=arr[i][0];
              k-=arr[i][1];
          }else if(k>0 && k<arr[i][1]){
              cost+=k*((double)arr[i][0]/arr[i][1]);
              break;
          }
        }
        System.out.printf("%.2f",cost);
    }
}

Job Sequencing Problem :
program:

import java.util.*;
class Main {
    public static void main(String[] args) {
        int[][] arr={{100, 1},{50, 2},{10, 2},{20, 3},{40, 4}};
        Arrays.sort(arr, (a, b)-> b[0]-a[0]);
        int maxd=0;
        for(int i=0; i<arr.length; i++){
            maxd=Math.max(maxd, arr[i][1]);
        }
        boolean[] slot=new boolean[maxd+1];
        int profit=0;
        for(int[] job:arr){
            int p=job[0], d=job[1];
            for(int t=d; t>=1; t--){
                if(!slot[t]){
                    profit+=p;
                    slot[t]=true;
                    break;
                }
            }
        }
        System.out.println(profit);
    }
}

Dynaic programming:

**Given a array and print number of possibilities of reaching given target:
import java.util.*;
class Main {
    public static void main(String[] args) {
        int target=4;
        int n=3;
        int[] arr={1, 2, 3};
        System.out.println(recursion(arr, n, target));
    }
    public static int recursion(int[] arr, int n, int target){
        if(target==0) return 1;
        if(target<0||n==0) return 0;
        return recursion(arr, n, target-arr[n-1])+recursion(arr, n-1, target);
    }
}
class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        int target = 4;
        List<Integer> current = new ArrayList<>();
        Arrays.sort(arr); // Optional: for sorted combinations
        System.out.println("Combinations (no order):");
        printCombinations(arr, arr.length, target, current);
    }

    public static void printCombinations(int[] arr, int n, int target, List<Integer> current) {
        if (target == 0) {
            System.out.println(current);
            return;
        }
        if (target < 0 || n == 0) return;

        // Include arr[n - 1]
        current.add(arr[n - 1]);
        printCombinations(arr, n, target - arr[n - 1], current);
        current.remove(current.size() - 1); // backtrack

        // Exclude arr[n - 1]
        printCombinations(arr, n - 1, target, current);
    }
}
for printing all combinations

Tabulation:
Recursion :
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        String s1 = sc.next(); 
        String s2 = sc.next(); 

        int length = lcs(s1, s2, s1.length(), s2.length());
        System.out.println("Length of Longest Common Subsequence: " + length);
    }
    public static int lcs(String s1, String s2, int i, int j) {
        if (i == 0 || j == 0) {
            return 0;
        }
        if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
            return 1 + lcs(s1, s2, i - 1, j - 1);
        }
        return Math.max(
            lcs(s1, s2, i - 1, j),
            lcs(s1, s2, i, j - 1)
        );
    }
}

import java.util.*;
class Node{
    int data;
    Node left, right;
    Node(int data){
        this.data=data;
        left=null;
        right=null;
    }
}
public class Main{
    static Scanner sc=new Scanner(System.in);
    static Node root=null;
    public static Node insert(Node root, int val){
        Node newNode=new Node(val);
        if(root==null) return root=newNode;
        if(val<root.data){
            root.left=insert(root.left, val);
        }else{
            root.right=insert(root.right, val);
        }
        return root;
    }
    public static void inorder(Node root){
        if(root==null) return;
        inorder(root.left);
        System.out.print(root.data+" ");
        inorder(root.right);
    }
    public static Node delete(Node root, int val){
        if(root==null) return null;
        if(root.data<val){
            root.right=delete(root.right,val);
        }else if(root.data>val){
            root.left=delete(root.left,val);
        }
        else{
            if(root.left==null) return root.right;
            if(root.right==null) return root.left;
            Node successor=findmin(root.right);
            root.data=successor.data;
            root.right=delete(root.right, successor.data);
        }
        return root;
    }
    public static Node findmin(Node root){
        while(root.left!=null){
            root=root.left;
        }return root;
    }
    public static void main(String[] args){
        while(true){
            String s=sc.next();
            if(s.equals("insert")){
                int val=sc.nextInt();
                root=insert(root, val);
            }else if (s.equals("inorder")) {
                System.out.print("inorder: ");
                inorder(root);
                System.out.println();
            }else if(s.equals("delete")){
                int val=sc.nextInt();
                root=delete(root, val);
            }
        }
    }
}

Bcktracking:
Rat in a maze:
Program:
import java.util.*;
class Main {
    static int n;
    static List<String> res=new ArrayList<>();
    static boolean[][] marking;
    public static List<String> direction(int[][] maze){
        n=maze.length;
        marking=new boolean[n][n];
        if(maze[0][0]==1){
            run(maze, 0, 0, "");
        }return res;
    }
    public static void run(int[][] maze, int x, int y, String dir){
        if(x==n-1 && y==n-1){
            res.add(dir);
            return;
        }
        marking[x][y]=true;
        // initial it is at (0,0) position,to move to down row we have to shift from present row to next row
        if(checking(x+1, y, maze)){
            run(maze, x+1, y, dir+"D"); // for down direction
        }if(checking(x, y+1, maze)){
            run(maze, x, y+1, dir+"R"); // for right direction
        }if(checking(x, y-1, maze)){
            run(maze, x, y-1, dir+"L"); // for left direction
        }if(checking(x-1, y, maze)){
            run(maze, x-1, y, dir+"T"); // for up direction
        }
        marking[x][y]=false;
    }
    public static boolean checking(int x, int y, int[][] maze){
        return x>=0 && y>=0 && x<n&&y<n&&maze[x][y]==1&&!marking[x][y];
    }
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int[][] maze=new int[n][n];
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                maze[i][j]=sc.nextInt();
            }
        }
        List<String> dir=direction(maze);
        if(dir.size()==0) {
            System.out.println("No solution found");
        }else{
            System.out.println("Solution found");
            for(String d: dir){
                System.out.print(d+" ");
            }
        }
    }
}

